= Gatling - demo
:toc:
:toc-placement:

== What is Gatling?

It is a performance load-testing tool that easily allows us to simulate traffic, and perform load testing as code, so we can integrate it with CI/CD and automation.

We can make use of the https://gatling.io/docs/gatling/tutorials/quickstart/#using-the-recorder[Recorder] to record a scenario or write our own using the Java/Scala DSL.

== Basics

Gatling has a couple of core concepts we should know:

* Virtual user: a dummy user implemented by Gatling as a message
* Session: each virtual user has a Session that act as placeholders which can be used to inject, or capture & store data.
* Scenario: the steps our virtual user has to perform
* Simulation: the definition of the test such as the number of users, HTTP protocol, acceptance criteria, hooks, throughput sharing, ...
* Recorder: the UI we can use to record a Scenario and output a Simulation
* Feeders: the API we use to inject data from external sources into the virtual user's session
* Checks: a response processor so that we can verify certain conditions, and optionally capture some information to store in the Session for later reuse
* Assertions: used to define acceptance criteria

Also keep in mind that in Gatling the default unit for Duration parameters is 1 second.

== Basic setup

A basic tests can consist of these three components

=== 1) The protocol

[code,java]
----
final HttpProtocolBuilder httpProtocol = http
    .baseUrl("http://localhost:8080")
    .acceptHeader("application/json")
    .userAgentHeader("Gatling performance Test");
----

This is the base configuration we'll be using for our API. +
_note: Gatling also supports JMS & MQTT_

=== 2) The scenario

[code,java]
----
ScenarioBuilder scenario = CoreDsl.scenario("Load Test greeting")
    .exec(http("get greeting")
            .get(session -> "/greet/" + UUID.randomUUID())
            .check(status().is(200))
    )
    .pause(5)
    .exec(http("Randomly slow")
            .get("/slow")
            .check(status().is(200))
    );
----

The scenario that we'll be executing. +
In this case we're invoking the greeting call, verifying that it's returning OK, waiting 5 seconds, invoking another endpoint and checking that ones status.
*note*: we are also giving out chain a label to make it easily identifiable in the output.

=== 3) The simulation

[code,java]
----
public GreetingSimulation() {
    this.setUp(scenario.injectOpen(constantUsersPerSec(100).during(Duration.ofSeconds(60))))
            .protocols(httpProtocol);
}
----

The simulation ties it all together. We set up our performance test for our given scenario, and define the amount of users and the duration of the test using the given protocol.

== Using the recorder

Once you've downloaded the recorder https://gatling.io/open-source/[from the website] you can start the Gatling recorder using the `recorder.sh` or `recorder.bat` within `$GATLING_HOME/bin/`

For this example we'll be making use of the https://computer-database.gatling.io/computers[Gatling sample application]

We start of by configuring the recorder

image::raw/recorder.png[]

And we configure the following settings

. proxy => HTTP proxy
. package => our desired package name
. class name => the simulation name
. format => Java 17
. settings => we follow redirects, infer HTML resources, enable automatic references and remove cache headers
. deny list => we click no static resources

Then we need to configure our proxy so that we can record the scenario:

image::raw/proxy.png[]

After this we can `start` our recording

For example let us:

* navigate to the site
* look up on `ACE`
* select the first result
* mark it as belonging to the first company
* save
* opt to create a new computer
* name it Sampler and save

And then hit `Save` in the recorder

And we'd end up with a recording akin to this link:raw/RecordedComputerSimulation.java[Sample recording].

=== Running the recording

==== Using the commandline tool

We can run the recording by using `gatling.sh` or `gatling.bat` within `$GATLING_HOME/bin/`

We'll be prompted for:

* whether to run locally/gatling cloud/package => we'll run it locally
* an optional description

After the run it will show us where we can find the simulation results

=== Using a build tool

==== General configuration

We can set up a `gatling.conf` file in `src\test\resources` to define global parameters such as the used encoding, SSL setup, shutdownTimeout, ... +
To view a list of possible parameters, and their defaults you can visit https://github.com/gatling/gatling/blob/main/gatling-core/src/main/resources/gatling-defaults.conf[their github repository].

===== Maven project

We need to add:

[code,xml]
----
<dependencies>
  <dependency>
    <groupId>io.gatling.highcharts</groupId>
    <artifactId>gatling-charts-highcharts</artifactId>
    <version>3.9.5</version>
    <scope>test</scope>
  </dependency>
</dependencies>

<plugin>
  <groupId>io.gatling</groupId>
  <artifactId>gatling-maven-plugin</artifactId>
  <version>4.4.0</version>
</plugin>
----

*note:* If your scenario was written/recorded as Scala you will need to use the `scala-maven-plugin`!

==== Gradle project

There are a couple of things we need to keep in mind:

* we'll need to be using at least Gradle 5
* in case of a multi-project build we should only add it to those containing Gatling simulations
* our simulations are expected to be located in: `src/gatling/{java|kotlin|scala}`

We'll need to add the following to our build file:

[code,groovy]
----
 plugins {
   id 'io.gatling.gradle' version "MANUALLY_REPLACE_WITH_LATEST_VERSION"
 }
----

==== Execution

We can use then put the recording in the expected location, and execute `mvn gatling:test` or `gradle gatlingRun` to perform our simulation. +
*note*: if you have multiple simulations you will either need to enable `runMultipleSimulations` in your configuration|commandline or specify the `simulationClass` in your configuration|commandline.

During the execution Gatling will output the progress of the current Simulation to the console, and at the end of each Simulation a summary of it.

After the execution we will find our report in `target` or `build` respectively. +
And we might end up with a report like this:

image::raw/result.png[]

== Diving a bit deeper

This all was quite a basic setup, now of course when we want to do this kind of testing we generally want to configure a lot more.

=== Splitting up our scenario

Now we have one big Simulation, now ideally we'd like to split this up so that we can reuse parts and make it more maintaineable in case the application under test changes.

We can achieve this by making use of `ChainBuilder`. Each portion would be a chain in our Scenario link.

So we can go from:

[code,java]
----
ScenarioBuilder sampleScenario = scenario("Load Test greeting")
    .exec(http("get greeting")
            .get(session -> "/greet/" + UUID.randomUUID())
            .check(status().is(200))
    )
    .pause(5)
    .exec(http("Randomly slow")
            .get("/slow")
            .check(status().is(200))
    );
----

to

[code,java]
----
ChainBuilder greeting = exec(http("get greeting")
        .get(session -> "/greet/" + UUID.randomUUID())
        .check(status().is(200))
)
        .pause(5);

ChainBuilder slowcall = exec(http("Randomly slow")
        .get("/slow")
        .check(status().is(200))
);

ScenarioBuilder sampleScenario2 = scenario("Load test greeting").exec(greeting, slowcall);
----

=== Configuring the protocol

The beforehand shown protocol configuration is quite basic, but a lot more can be done with it.

* customizing the url used to warm up the Java/NIO engine (or disable this warm up) using `warmUp(url)` and `disableWarmup()` respectively
* configure the maximum number of connections per host `maxConnectionsPerHost(N)`
* switch the behaviour from client => browser to behave more like server => server by using `shareConnections()`
* configure host name aliasing `hostNameAliases(...)`
* configure the virtual host `virtualHost(N)`
* disable caching `disableCaching()`
* ...

For example:
[code,java]
----
private HttpProtocolBuilder httpProtocol = http
    .baseUrl("https://computer-database.gatling.io")
    .acceptEncodingHeader("gzip, deflate, br")
    .acceptLanguageHeader("en-GB,en;q=0.9,nl;q=0.8")
    .disableCaching()
    .upgradeInsecureRequestsHeader("1");
----

For a full list you can check:

* https://gatling.io/docs/gatling/reference/current/http/protocol/[HTTP protocol documentation]
* https://gatling.io/docs/gatling/reference/current/jms/#protocol[JMS protocol documentation]
* https://gatling.io/docs/gatling/reference/current/mqtt/#mqtt-protocol[MQTT protocol documentation]

=== User management

Now in the sample recording we've made there's 1 user. That's nice to run through the flow, but that will (hopefully) not expose any performance issues in your project.

Gatling supports 2 different workload models for users:

* closed: we control the *concurrent* number of users
* open: we control the *arrival rate* of users

this API allows us to define things such as:

* ramp up period
* stress peak
* constant number of users per second during a certain time
* ...

For example we could have this setup:
[code,java]
----
sampleScenario.injectOpen(
    nothingFor(20), // nothing for 20 seconds
    atOnceUsers(100), // 100 users at once, once the click hits 9:00
    rampUsers(50).during(60) // evenly add 50 users over 60 seconds as they sip their coffee
)
----

This allows us to mimic behaviours like call centers/morning rush/...

A full list of details can be found on the https://gatling.io/docs/gatling/reference/current/core/injection/[injection] page.

== Notes
* Gatling as a standalone bundle can be used for Scala and Java, for Kotlin you'll need a `Maven` or `Gradle` project.

* Gatling requires Java 8 or higher

== References
* https://gatling.io/[Gatling official website]
* https://gatling.io/enterprise/[Gatling enterprise offering] - both self-hosted, and as cloud
* https://computer-database.gatling.io/computers[Gatling sample application] - this application is provided by Gatling to be targeted by the recorder
= Gatling - demo
:toc:
:toc-placement:

== What is Gatling?

It is a performance load-testing tool that easily allows us to simulate traffic, and perform load testing as code, so we can integrate it with CI/CD and automation.

We can make use of the https://gatling.io/docs/gatling/tutorials/quickstart/#using-the-recorder[Recorder] to record a scenario or write our own using the Java/Scala DSL.

== Basics

Gatling has a couple of core concepts we should know:

* Virtual user: a dummy user implemented by Gatling as a message
* Session: each virtual user has a Session that act as placeholders which can be used to inject, or capture & store data.
* Scenario: the steps our virtual user has to perform
* Simulation: the definition of the test such as the number of users, HTTP protocol, acceptance criteria, hooks, throughput sharing, ...
* Recorder: the UI we can use to record a Scenario and output a Simulation
* Feeders: the API we use to inject data from external sources into the virtual user's session
* Checks: a response processor so that we can verify certain conditions, and optionally capture some information to store in the Session for later reuse
* Assertions: used to define acceptance criteria

Also keep in mind that in Gatling the default unit for Duration parameters is 1 second.

== Basic setup

A basic tests can consist of these three components

=== 1) The protocol

[code,java]
----
final HttpProtocolBuilder httpProtocol = http
    .baseUrl("http://localhost:8080")
    .acceptHeader("application/json")
    .userAgentHeader("Gatling performance Test");
----

This is the base configuration we'll be using for our API. +
_note: Gatling also supports JMS & MQTT_

=== 2) The scenario

[code,java]
----
ScenarioBuilder scenario = CoreDsl.scenario("Load Test greeting")
    .exec(http("get greeting")
            .get(session -> "/greet/" + UUID.randomUUID())
            .check(status().is(200))
    )
    .pause(5)
    .exec(http("Randomly slow")
            .get("/slow")
            .check(status().is(200))
    );
----

The scenario that we'll be executing. +
In this case we're invoking the greeting call, verifying that it's returning OK, waiting 5 seconds, invoking another endpoint and checking that ones status.
*note*: we are also giving out chain a label to make it easily identifiable in the output.

=== 3) The simulation

[code,java]
----
public GreetingSimulation() {
    this.setUp(scenario.injectOpen(constantUsersPerSec(100).during(Duration.ofSeconds(60))))
            .protocols(httpProtocol);
}
----

The simulation ties it all together. We set up our performance test for our given scenario, and define the amount of users and the duration of the test using the given protocol.

== Using the recorder

Once you've downloaded the recorder https://gatling.io/open-source/[from the website] you can start the Gatling recorder using the `recorder.sh` or `recorder.bat` within `$GATLING_HOME/bin/`

For this example we'll be making use of the https://computer-database.gatling.io/computers[Gatling sample application]

We start of by configuring the recorder

image::raw/recorder.png[]

And we configure the following settings

. proxy => HTTP proxy
. package => our desired package name
. class name => the simulation name
. format => Java 17
. settings => we follow redirects, infer HTML resources, enable automatic references and remove cache headers
. deny list => we click no static resources

Then we need to configure our proxy so that we can record the scenario:

image::raw/proxy.png[]

After this we can `start` our recording

For example let us:

* navigate to the site
* look up on `ACE`
* select the first result
* mark it as belonging to the first company
* save
* opt to create a new computer
* name it Sampler and save

And then hit `Save` in the recorder

And we'd end up with a recording akin to this link:raw/RecordedComputerSimulation.java[Sample recording].

=== Running the recording

==== Using the commandline tool

We can run the recording by using `gatling.sh` or `gatling.bat` within `$GATLING_HOME/bin/`

We'll be prompted for:

* whether to run locally/gatling cloud/package => we'll run it locally
* an optional description

After the run it will show us where we can find the simulation results

=== Using a build tool

=== General configuration

We can set up a `gatling.conf` file in `src\test\resources` to define global parameters such as the used encoding, SSL setup, shutdownTimeout, ... +
To view a list of possible parameters, and their defaults you can visit https://github.com/gatling/gatling/blob/main/gatling-core/src/main/resources/gatling-defaults.conf[their github repository].

==== Maven project

We need to add:

[code,xml]
----
<dependencies>
  <dependency>
    <groupId>io.gatling.highcharts</groupId>
    <artifactId>gatling-charts-highcharts</artifactId>
    <version>3.9.5</version>
    <scope>test</scope>
  </dependency>
</dependencies>

<plugin>
  <groupId>io.gatling</groupId>
  <artifactId>gatling-maven-plugin</artifactId>
  <version>4.4.0</version>
</plugin>
----

*note:* If your scenario was written/recorded as Scala you will need to use the `scala-maven-plugin`!

=== Gradle project

There are a couple of things we need to keep in mind:

* we'll need to be using at least Gradle 5
* in case of a multi-project build we should only add it to those containing Gatling simulations
* our simulations are expected to be located in: `src/gatling/{java|kotlin|scala}`

We'll need to add the following to our build file:

[code,groovy]
----
 plugins {
   id 'io.gatling.gradle' version "MANUALLY_REPLACE_WITH_LATEST_VERSION"
 }
----

=== Execution

We can use then put the recording in the expected location, and execute `mvn gatling:test` or `gradle gatlingRun` to perform our simulation. +
*note*: if you have multiple simulations you will either need to enable `runMultipleSimulations` in your configuration|commandline or specify the `simulationClass` in your configuration|commandline.

During the execution Gatling will output the progress of the current Simulation to the console, and at the end of each Simulation a summary of it.

After the execution we will find our report in `target` or `build` respectively. +
And we might end up with a report like this:

image::raw/result.png[]

== Diving a bit deeper

=== Splitting up our scenario

Now we have one big Simulation, now ideally we'd like to split this up so that we can reuse parts and make it more maintaineable in case the application under test changes.

We can achieve this by making use of `ChainBuilder`. Each portion would be a chain in our Scenario link.

So we can go from:

[code,java]
----
ScenarioBuilder sampleScenario = scenario("Load Test greeting")
    .exec(http("get greeting")
            .get(session -> "/greet/" + UUID.randomUUID())
            .check(status().is(200))
    )
    .pause(5)
    .exec(http("Randomly slow")
            .get("/slow")
            .check(status().is(200))
    );
----

to

[code,java]
----
ChainBuilder greeting = exec(http("get greeting")
        .get(session -> "/greet/" + UUID.randomUUID())
        .check(status().is(200))
)
        .pause(5);

ChainBuilder slowcall = exec(http("Randomly slow")
        .get("/slow")
        .check(status().is(200))
);

ScenarioBuilder sampleScenario2 = scenario("Loead test greeting").exec(greeting, slowcall);
----

== Notes
* Gatling as a standalone bundle can be used for Scala and Java, for Kotlin you'll need a `Maven` or `Gradle` project.

* Gatling requires Java 8 or higher

== References
* https://gatling.io/[Gatling official website]
* https://computer-database.gatling.io/computers[Gatling sample application] - this application is provided by Gatling to be targeted by the recorder